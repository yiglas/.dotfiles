-- local api = vim.api
-- local uv = vim.loop
--
-- local function show_time_float()
--   local buf = api.nvim_create_buf(false, true)
--
--   -- Set initial time and compute exact width of the text
--   local function get_time_str()
--     return "  ðŸ•’ " .. os.date("%H:%M")
--   end
--
--   local time_str = get_time_str()
--   local width = #time_str
--   local height = 1
--
--   api.nvim_buf_set_lines(buf, 0, -1, false, { time_str })
--
--   local win = api.nvim_open_win(buf, false, {
--     relative = "editor",
--     width = width,
--     height = height,
--     row = 0,
--     col = (vim.o.columns - width) / 2,
--     style = "minimal",
--     border = nil, -- ðŸ”§ no border = no visual padding
--     focusable = false,
--     noautocmd = true,
--   })
--
--   local timer = uv.new_timer()
--
--   local function schedule_next_tick()
--     local now = os.time()
--     local next_min = (math.floor(now / 60) + 1) * 60
--     local delay_ms = (next_min - now) * 1000
--
--     timer:start(
--       delay_ms,
--       0,
--       vim.schedule_wrap(function()
--         if api.nvim_buf_is_valid(buf) and api.nvim_win_is_valid(win) then
--           local new_time_str = get_time_str()
--           api.nvim_buf_set_lines(buf, 0, -1, false, { new_time_str })
--
--           local new_width = #new_time_str
--           if new_width ~= width then
--             width = new_width
--             api.nvim_win_set_config(win, {
--               width = width,
--               col = (vim.o.columns - width) / 2,
--             })
--           end
--
--           schedule_next_tick()
--         else
--           timer:stop()
--           timer:close()
--         end
--       end)
--     )
--   end
--
--   schedule_next_tick()
-- end
--
-- show_time_float()
--
return {}
